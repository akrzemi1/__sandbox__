<html><head></head>
<body>

<h2>3.2. Mathematical soundness</h2>

<p>In this section we respond to the claim that the requirement on <code>CommonReference</code> is <em>required</em>
   to make concept <code>StrictWeakOrdering</code> "mathematically sound".
   </p>
   
<p>The notion of being "mathematically sound" has no formal definition and is subject to personal judgement or aesthetic preference.
   In order to facilitate the discussion we would need to define it. One possible attempt would be, based on the observation that in 
   mathematics the concept of <em>strict weak ordering</em> is described for elements from one domain <em>C</em>,
   would be to apply sufficient transformations (however difficult, impractical or error prone) to create a single type <code>C</code>
   and express the axioms token-by-token as they are spelled out in mathematics for objects of type <code>C</code>. We do not propose this,
   and instead offer the following alternative. Provide a formal system based on the mathematical concept of <em>strict weak ordering</em>
   that preserves its essential properties and gives us the benefits of the mathematical concept, but works for two types
   <code>T</code> and <code>U</code> without requiring a common type and corresponding conversions.
   </p>
   
<p>What do we require of the syntactic and semantic constraints on concepts:
   </p>
   
   <ol><li>That they are sufficient to describe preconditions and postconditions on functions dealing with order.
           </li>
       <li>That they are sufficient for the run-time injected diagnostic code (such as inside <code>assert()</code>) to be able
           to test if all the semantic constraints were met.
           </li>
      </ol>
   
<p>We believe the semantic constraints expressed with the following functions meet the above requirements:
   </p> 
   
<pre>template &lt;typename A&gt;
bool irreflexivity(const A&amp; a)
{
  return !comp(a, a);
}

template &lt;typename A, typename B&gt;
bool asymmetry(const A&amp; a, const B&amp; b)
{
  if (comp(a, b))
    return !comp(b, a);
  return true;     
}

template &lt;typename A, typename B, typename C&gt;
bool transitivity(const A&amp; a, const B&amp; b, const C&amp; c)
{
  if (comp(a, b))
    if (comp(b, c))
      return comp(a, c);
  return true;     
}

template &lt;typename A, typename B, typename C&gt;
bool transitivity_of_equivalence(const A&amp; a, const B&amp; b, const C&amp; c)
{
  if (!comp(a, b) &amp;&amp; !comp(b, a))
    if (!comp(b, c) &amp;&amp; !comp(c, b))
      return !comp(a, c) &amp;&amp; !comp(c, a);
  return true;     
}
</pre>   
   
<p>Where each <code>A</code>, <code>B</code>, <code>C</code> can be either <code>T</code> or <code>U</code>.
   These require that the predicate apart from working for <code>comp(t, u)</code> and <code>comp(u, t)</code>
   also needs to work for <code>comp(t, t)</code> and <code>comp(u, u)</code>, but require no existence of
   a common type or conversions to this common type.   
   </p>   
   
</body>
</html>
