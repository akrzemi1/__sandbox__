:sourcedir: .
:last-update-label!:
:source-highlighter: coderay
:icons: font
= Markable - API Reference
Reference
:toclevels: 3
:toc: left
:toc-title:

[reference]
== Reference

```c++
namespace ak_toolkit
{
  namespace markable_ns
  {
    template <typename MP, typename Tag>
      class markable;
    
    void swap(markable & l, markable & r);

    template <typename T, typename NT = T, typename CREF = const T&, typename REPT = NT>
      struct markable_type;
    
    template <typename T, T Val>
      struct mark_int;
      
    template <typename FPT>
      struct mark_fp_nan;
      
    template <typename T>
      struct mark_value_init;
      
    template <typename T>
      struct mark_stl_empty;
      
    template <typename OT>
      struct mark_optional;
      
    struct mark_bool;
    
    template <typename Enum, std::underlying_type_t<Enum> Val> 
      struct mark_enum;
       
    template <typename MP>
      struct dual_storage;
      
    template <typename MP>
      void swap(dual_storage & l, dual_storage & r);
      
    template <typename MPT, typename T, typename DUAL_T>
      struct markable_dual_storage_type;
  }

  using markable_ns::markable;
  using markable_ns::markable_type;
  using markable_ns::markable_pod_storage_type;
  using markable_ns::mark_bool;
  using markable_ns::mark_int;
  using markable_ns::mark_fp_nan;
  using markable_ns::mark_value_init;
  using markable_ns::mark_optional;
  using markable_ns::mark_stl_empty;
  using markable_ns::mark_enum;
  using markable_ns::dual_storage;
}
```

[concept_mark_policy]
== Concept `Mark_policy`

```c++
template <typename SP>
concept bool Mark_policy =
  requires
  {
    typename MP::value_type;
    typename MP::storage_type;
    typename MP::reference_type;
    typename MP::representation_type;
  } &&
  requires(const typename MP::representation_type & r
           const typename MP::storage_type &        s,
           const typename MP::value_type &          cv,
                 typename MP::value_type &&         rv)
  {   
    { MP::marked_value() }              -> typename MP::representation_type;
    { MP::is_marked_value(r) } noexcept -> bool;
    
    { MP::access_value(s) }             -> typename MP::reference_type;
    { MP::representation(s) } noexcept  -> const typename MP::representation_type &;
    { MP::store_value(cv) }             -> typename MP::storage_type;
    { MP::store_value(std::move(rv)) }  -> typename MP::storage_type;
  };
```
