:sourcedir: .
:last-update-label!:
:source-highlighter: coderay
:icons: font
= Markable - API Reference
Reference
:toclevels: 3
:toc: left
:toc-title:

[reference]
== Reference

```c++
namespace ak_toolkit
{
  namespace markable_ns
  {
    template <typename MP, typename Tag>
      class markable;
    
    void swap(markable & l, markable & r);

    template <typename T, typename NT = T, typename CREF = const T&, typename REPT = NT>
      struct markable_type;
           
    template <typename MP>
      struct dual_storage;
      
    template <typename MP>
      void swap(dual_storage & l, dual_storage & r);
      
    template <typename MPT, typename T, typename DUAL_T>
      struct markable_dual_storage_type;
    
    template <typename T, T Val>
      struct mark_int;
      
    template <typename FPT>
      struct mark_fp_nan;
      
    template <typename T>
      struct mark_value_init;
      
    template <typename T>
      struct mark_stl_empty;
      
    template <typename OT>
      struct mark_optional;
      
    struct mark_bool;
    
    template <typename Enum, std::underlying_type_t<Enum> Val> 
      struct mark_enum;
  }

  using markable_ns::markable;
  using markable_ns::markable_type;
  using markable_ns::markable_dual_storage_type;
  using markable_ns::mark_bool;
  using markable_ns::mark_int;
  using markable_ns::mark_fp_nan;
  using markable_ns::mark_value_init;
  using markable_ns::mark_optional;
  using markable_ns::mark_stl_empty;
  using markable_ns::mark_enum;
  using markable_ns::dual_storage;
}
```

[concept_mark_policy]
== Concept `Mark_policy`

```c++
template <typename SP>
concept bool Mark_policy =
  requires
  {
    typename MP::value_type;
    typename MP::storage_type;
    typename MP::reference_type;
    typename MP::representation_type;
  } &&
  requires(const typename MP::representation_type & r
           const typename MP::storage_type &        s,
           const typename MP::value_type &          cv,
                 typename MP::value_type &&         rv)
  {   
    { MP::marked_value() }              -> typename MP::representation_type;
    { MP::is_marked_value(r) } noexcept -> bool;
    
    { MP::access_value(s) }             -> typename MP::reference_type;
    { MP::representation(s) } noexcept  -> const typename MP::representation_type &;
    { MP::store_value(cv) }             -> typename MP::storage_type;
    { MP::store_value(std::move(rv)) }  -> typename MP::storage_type;
  };
```


#### `value_type`
This represents the type 'logically' stored by the markable object. Markable object tries to make an impression on the users that it is internally storing an objectof type `value_type`, which is often the case, but not always.

#### `storage_type`
This represents the type of the sub-object physically stored inside markable object, which is used to store the value of the object as well as the empty-state mark. 

#### `reference_type`
This represents the type returned when the user requests read access to the stored value. Typically, this type is defined as `const value_type&`, however, sometimes when the accessed value is computed on the fly, this type may be defined as `value_type`.

#### `representation_type`
It is in this type that the special marked value is encoded. Typically, this is `storage_type`, but in some cases `storage_type` neds to be cast to this type.

#### `{ marked_value() } -> representation_type`
Returns a marked value encoded in `representation_type`. This will be later used to represent a markable object with no value.

#### `{ is_marked_value(r) } -> bool`
Checks if the given value represents a marked value.

#### `{ access_value(s) } -> reference_type`
*Preconditions:* `!is_marked_value(s)`.

Given a value encoded in `storage_type`, provides access to it through type `reference_type`. Typically, when `reference_type` and `const storage_type&` are same type, this is an identity function.

#### `{ MP::representation(s) } noexcept  -> const representation_type &`

Performs adjustments (if necessary) to represent the stored object through `representation_type`.

#### `{ store_value(v) } -> storage_type`
Given a value of type `value_type` (possibly marked), returns its representation as `storage_type`. Typically, when `value_type` and `storage_type` are same type, this is an identity function.

## Class template `markable`

```c++
namespace ak_toolkit
{
  namespace markable_ns
  {
    template <Mark_policy MP>
    class markable
    {
    public:
      typedef typename MP::value_type     value_type;
      typedef typename MP::storage_type   storage_type;
      typedef typename MP::reference_type reference_type;

      constexpr markable() noexcept(noexcept(storage_type{MP::marked_value{}}));
      constexpr explicit markable(const value_type& v);
      constexpr explicit markable(value_type&& v);
      constexpr markable(const markable&) = default;
      constexpr markable(markable&&) = default;
      
      constexpr markable& operator=(const markable&) = default;
      constexpr markable& operator=(markable&&) = default;
      
      constexpr bool has_value() const;
      constexpr reference_type value() const;
      constexpr storage_type const& storage_value() const;
      
    private:
      storage_type val_; // exposition only
    };
  }
}
```

#### `markable()`

*Effects:* Initializes storage value with expression `MP::marked_value()`. 

*Postconditions:* `!has_value()`.

#### `markable(const value_type& v)`

*Effects:* Initializes storage value with expression `MP::store_value(v)`. 

*Postconditions:* `has_value() == !MP::is_marked_value(v)`.

#### `markable(value_type&& v)`

*Effects:* Initializes storage value with expression `MP::store_value(std::move(v))`. 

*Postconditions:* `has_value() == !MP::is_marked_value(v)`.

#### `reference_type has_value() const`

*Returns:* `!MP::is_marked_value(val_)`.

*Throws:* Nothing.


#### `reference_type value() const`

*Preconditions:* `has_value()`.

*Returns:* `MP::access_value(val_)`.

*Throws:* Whatever `MP::access_value` throws. Also, if `reference_type` is in fact not a reference type, whatever `reference_type`'s move constructor throws.


#### `storage_type const& storage_value() const`

*Returns:* `val_`.

*Throws:* Nothing.

### Exception safety

If an exception is thrown during the assignment, the state of `*this` depends on the exception safety guarantees of `storage_type`. If `storage_type` offers a weak guarantee, the corresponding `markable<>` type also offers only a weak guarantee. In particular, the value of `has_value()` may change.


## Mark policy creation tools

The follwoing tools help build custom mark policies.

### Class template `markable_type`

This class template provides default definitions form most of the requirements in concept `Mark_policy`. When declaring your own mark policy, you probably want to derive from this class template (although it is not strictly necessary). 

```c++
template <typename T, typename STORE = T, typename CREF = const T&, typename REPT = NT>
struct markable_type
{
  typedef T     value_type;
  typedef STORE storage_type;
  typedef CREF  reference_type;
  typedef REPT  representation_type;
  
  static constexpr reference_type access_value(const storage_type& v) { return v; }
  static constexpr const representation_type& representation(const storage_type& v) { return v; }
  static constexpr const value_type& store_value(const value_type& v) { return v; }
  static constexpr value_type&& store_value(value_type&& v) { return std::move(v); }
};
```

### Class template `markable_dual_storage_type`

```c++
template <typename MPT, typename T, typename DUAL_T>
struct markable_dual_storage_type
{
  typedef T                 value_type;
  typedef DUAL_T            representation_type;
  typedef const T&          reference_type;
  typedef dual_storage<MPT> storage_type;
  
  static reference_type access_value(const storage_type& v) { return v.as_value_type(); }
  static const representation_type& representation(const storage_type& v) { return v.representation(); }
  static storage_type store_value(const value_type& v) { return storage_type(v); }
  static storage_type store_value(value_type&& v) { return storage_type(std::move(v)); } 
};
```

*Requires:* `MPT` is a model of `Mark_policy`; `T` and `DUAL_T` are layout-compatible types.
