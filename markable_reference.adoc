:sourcedir: .
:last-update-label!:
:source-highlighter: coderay
:icons: font
= Markable - API Reference
Reference
:toclevels: 3
:toc: left
:toc-title:

[reference]
== Reference


### Class template `dual_storage`

Class used to store inside a union members of type `value_type` and `representation_type`, and manage them appropriately.

```c++
template <typename MP>
struct dual_storage
{
  typedef typename MP::value_type value_type;
  typedef typename MP::representation_type representation_type;
  typedef typename MP::reference_type reference_type;
  
  bool has_value() const /*noexcept*/; // need to consider noexcept (if not too harsh)
  void clear_value() noexcept;
  value_type&        as_value();
  const value_type&  as_value() const;
  representation_type&       representation()       noexcept;
  const representation_type& representation() const noexcept;
  
  constexpr dual_storage(representation_type&& mv) noexcept(/*see below*/);
  constexpr explicit dual_storage(const value_type& v) noexcept(noexcept(value_type(v))));
  constexpr explicit dual_storage(value_type&& v) noexcept(noexcept(value_type(std::move(v))));
  dual_storage(const dual_storage& rhs); // TODO: add noexcept
  dual_storage(dual_storage&& rhs); // TODO: add noexcept    
  void operator=(const dual_storage& rhs);    
  void operator=(dual_storage&& rhs); // TODO: add noexcept  
  friend void swap(dual_storage& lhs, dual_storage& rhs);  // TODO: add conditional noexcept
  ~dual_storage();
};
```

An object of `dual_storage` contains a union of two members of types `value_type` and `representation_type`.
Such object is said to _have value_ if its active member is of type `value_type`.
Types `value_type` and `representation_type` shall be layout-compatible.

#### `bool has_value() const;`
*Returns:* `!MP::is_marked_value(representation())`.

*Remarks:* This tests if the object has value.

#### `void clear_value() noexcept;`

*Preconditions:* `has_value() == true`.

*Effects:* destroys the active member of type `value_type`; next, initializes member of type `representation_type`
with expression `MP::marked_value()`.

*Remarks:* If an expression is thrown during the initialization of member of type `representation_type`, function `std::terminate()` is called.

#### `value_type&        as_value();`
#### `const value_type&  as_value() const;`
*Preconditions:* `has_value() == true`.

*Returns:* a reference to the active union member of type `value_type`.

#### `representation_type&       representation()       noexcept;`
#### `const representation_type& representation() const noexcept;`

*Effects:* if `has_value() == false` returns a reference to the active union member of type `representation_type`;
otherwise accesses the inactive union member `representation_type` and throug common initial sequence accesses the value of active member `value_type` and returns thus obtained reference.

#### `constexpr dual_storage(representation_type&& mv) noexcept(/\*see below*/)`

*Effects:* Initializes the union member of type `representation_type` with expression `std::move(mv)`.

*Postcondition:* `has_value() == !MP::is_marked_value(mv)`. 

*Remarks:* The expression inside `noexcept` is equivalent to `std::is_move_constructible_v<representation_type>`.

#### `friend void swap(dual_storage& lhs, dual_storage& rhs);` ?? noexcept ??

*Effects:
|===
|  |  `lhs.has_value()` | `!lhs.has_value()`

| `rhs.has_value()`
| calls `swap(lhs.as_value(), rhs.as_value())` (ADL also searches in `std`)
| cscs

| `!rhs.has_value()`
| cecec
| no effect
|===

#### `~dual_storage();`
*Effects:* if `has_value() == true`, destroys the active member of type `value_type`, otherwise destroys the active member of `representation_type`.

