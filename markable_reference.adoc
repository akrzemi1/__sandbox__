:sourcedir: .
:last-update-label!:
:source-highlighter: coderay
:icons: font
= Markable - API Reference
Reference
:toclevels: 3
:toc: left
:toc-title:

[reference]
== Reference


### Class template `dual_storage`

Class used to store inside a union members of type `value_type` and `representation_type`, and manage them appropriately.

```c++
template <typename MP>
struct dual_storage
{
  typedef typename MP::value_type value_type;
  typedef typename MP::representation_type representation_type;
  typedef typename MP::reference_type reference_type;
  
  bool has_value() const /*noexcept*/; // need to consider noexcept (if not too harsh)
  value_type&        as_value();
  const value_type&  as_value() const;
  representation_type&       representation()       noexcept;
  const representation_type& representation() const noexcept;
  
  constexpr dual_storage(representation_type&& mv) noexcept(noexcept(representation_type(std::move(mv)))));
  constexpr explicit dual_storage(const value_type& v) noexcept(noexcept(value_type(v))));
  constexpr explicit dual_storage(value_type&& v) noexcept(noexcept(value_type(std::move(v))));
  dual_storage(const dual_storage& rhs); // TODO: add noexcept
  dual_storage(dual_storage&& rhs); // TODO: add noexcept    
  void operator=(const dual_storage& rhs);    
  void operator=(dual_storage&& rhs); // TODO: add noexcept  
  friend void swap(dual_storage& lhs, dual_storage& rhs);  // TODO: add conditional noexcept
  ~dual_storage();
};
```

An object of `dual_storage` contains a union of two members of types `value_type` and `representation_type`.
Such object is said to _have value_ if its active member is of type `value_type`.
Types `value_type` and `representation_type` shall be layout-compatible.

#### `bool has_value() const;`
*Returns:* `!MP::is_marked_value(representation())`.

*Remarks:* This tests if the object has value.

#### `value_type&        as_value();`
#### `const value_type&  as_value() const;`
*Preconditions:* `has_value() == true`.

*Returns:* a reference to the active union member of type `value_type`.

#### `representation_type&       representation()       noexcept;`
#### `const representation_type& representation() const noexcept;`

*Effects:* if `has_value() == false` returns a reference to the active union member of type `representation_type`;
otherwise accesses the inactive union member `representation_type` and throug common initial sequence accesses the value of active member `value_type` and returns thus obtained reference.

#### `~dual_storage();`
*Effects:* if `has_value() == true`, destroys the active member of type `value_type`, otherwise destroys the active member of `representation_type`.

